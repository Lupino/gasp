{{={= =}=}}

report_attr_index int = 0
report_metric_index int = 0

{=# attrs =}

attr_{= name =} {= type =} = {= default =}
cache_attr_{= name =} {= type =} = {= default =}
last_attr_{= name =} {= type =} = {= default =}
attr_{= name =}_force bool = true
attr_{= name =}_reported bool = false

{=# has_app =}
{=# keep =}
setup setup_attr_{= name =} {
    {=# onebyte =}
    attr_{= name =} = STROAGE_READ({= addr =});
    {=/ onebyte =}
    {=^ onebyte =}
    STROAGE_GET({= addr =}, attr_{= name =});
    {=/ onebyte =}
    {=# is_float =}
    if (!is_valid_float(attr_{= name =}, {= scaled_min =}, {= scaled_max =})) {
    {=/ is_float =}
    {=^ is_float =}
    {=# uncheckmin =}
    if (attr_{= name =} > {= scaled_max =}) {
    {=/ uncheckmin =}
    {=^ uncheckmin =}
    if (attr_{= name =} < {= scaled_min =} || attr_{= name =} > {= scaled_max =}) {
    {=/ uncheckmin =}
    {=/ is_float =}
        attr_{= name =} = {= default =};
    }
}
{=/ keep =}
{=/ has_app =}

func set_attr_{= name =}_raw(unscaled_value {= type =}) void {
    attr_{= name =}_force = true;
    attr_{= name =} = unscaled_value * {= scale =};
    {=# keep =}
    {=# onebyte =}
    STROAGE_WRITE({= addr =}, attr_{= name =});
    {=/ onebyte =}
    {=^ onebyte =}
    STROAGE_PUT({= addr =}, attr_{= name =});
    {=/ onebyte =}
    STROAGE_COMMIT();
    {=/ keep =}
}


func set_attr_{= name =}(json const char *, tokens jsmntok_t *, num_tokens int, retval char *) bool {
    if (jsonlookup(json, tokens, num_tokens, FROM_ROM(TO_ROM("data")), requestValue)) {
        {=# is_float =}
        float tmp;
        bool r = prepare_float(&tmp, retval, requestValue, {= min =}, {= max =});
        {=/ is_float =}
        {=^ is_float =}
        long tmp;
        bool r = prepare_long(&tmp, retval, requestValue, {= min =}, {= max =});
        {=/ is_float =}
        if (!r) {
            return false;
        }
        set_attr_{= name =}_raw(({= type =})tmp);
        {=# has_event =}
        {= event =}(({= type =})tmp);
        {=/ has_event =}
    }
    get_attr_{= name =}(retval);
    return true;
}

func get_attr_{= name =}(retval char *) bool {
    {=^ is_float =}
    {=# is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %ld}")), ({= type =})attr_{= name =} / {= scale =});
    {=/ is_long =}
    {=^ is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %d}")), ({= type =})attr_{= name =} / {= scale =});
    {=/ is_long =}
    {=/ is_float =}
    {=# is_float =}
    dtostrf(({= type =})attr_{= name =} / {= scale =}, {= width =}, {= prec =}, requestValue);
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %s}")), ltrim(requestValue));
    {=/ is_float =}
    return true;
}

{=/ attrs =}

{=# metrics =}
metric_{= name =} {= type =} = 0
cache_metric_{= name =} {= type =} = 0
last_metric_{= name =} {= type =} = 0
metric_{= name =}_reported bool = true
metric_{= name =}_readed bool = false

{=# auto =}
metric_{= name =}_threshold {= type =} = {= threshold =}
cache_metric_{= name =}_threshold {= type =} = {= threshold =}
last_metric_{= name =}_threshold {= type =} = {= threshold =}
metric_{= name =}_threshold_force bool = true
metric_{= name =}_threshold_reported bool = false

{=# has_app =}
setup setup_metric_{= name =} {
    {=# onebyte =}
    metric_{= name =}_threshold = STROAGE_READ({= addr =});
    {=/ onebyte =}
    {=^ onebyte =}
    STROAGE_GET({= addr =}, metric_{= name =}_threshold);
    {=/ onebyte =}
    {=# is_float =}
    if (!is_valid_float(metric_{= name =}_threshold, {= min_threshold =}, {= max_threshold =})) {
    {=/ is_float =}
    {=^ is_float =}
    {=# uncheckmin =}
    if (metric_{= name =}_threshold > {= max_threshold =}) {
    {=/ uncheckmin =}
    {=^ uncheckmin =}
    if (metric_{= name =}_threshold < {= min_threshold =} || metric_{= name =}_threshold > {= max_threshold =}) {
    {=/ uncheckmin =}
    {=/ is_float =}
        metric_{= name =}_threshold = {= threshold =};
    }
}
{=/ has_app =}

func set_metric_{= name =}_threshold(json const char *, tokens jsmntok_t *, num_tokens int, retval char *) bool {
    if (jsonlookup(json, tokens, num_tokens, FROM_ROM(TO_ROM("data")), requestValue)) {
        {=# is_float =}
        float tmp;
        bool r = prepare_float(&tmp, retval, requestValue, {= min_threshold =}, {= max_threshold =});
        {=/ is_float =}
        {=^ is_float =}
        long tmp;
        bool r = prepare_long(&tmp, retval, requestValue, {= min_threshold =}, {= max_threshold =});
        {=/ is_float =}
        if (!r) {
            return false;
        }
        metric_{= name =}_threshold = ({= type =})tmp;
        metric_{= name =}_threshold_force = true;
        {=# onebyte =}
        STROAGE_WRITE({= addr =}, metric_{= name =}_threshold);
        {=/ onebyte =}
        {=^ onebyte =}
        STROAGE_PUT({= addr =}, metric_{= name =}_threshold);
        {=/ onebyte =}
        STROAGE_COMMIT();
    }
    get_metric_{= name =}_threshold(retval);
    return true;
}

func get_metric_{= name =}_threshold(retval char *) bool {
    {=^ is_float =}
    {=# is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}_threshold\": %ld}")), metric_{= name =}_threshold);
    {=/ is_long =}
    {=^ is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}_threshold\": %d}")), metric_{= name =}_threshold);
    {=/ is_long =}
    {=/ is_float =}
    {=# is_float =}
    dtostrf(metric_{= name =}_threshold, {= width =}, {= prec =}, requestValue);
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}_threshold\": %s}")), ltrim(requestValue));
    {=/ is_float =}
    return true;
}

{=/ auto =}
func check_metric_{= name =}() bool {
    {=# is_float =}
    return is_valid_float(metric_{= name =}, {= min =}, {= max =});
    {=/ is_float =}
    {=^ is_float =}
    return metric_{= name =} >= {= min =} && metric_{= name =} <= {= max =};
    {=/ is_float =}
}

func get_metric_{= name =}(retval char *) bool {
    if (!check_metric_{= name =}()) {
        return err_invalid(retval);
    }
    {=^ is_float =}
    {=# is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %ld}")), metric_{= name =});
    {=/ is_long =}
    {=^ is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %d}")), metric_{= name =});
    {=/ is_long =}
    {=/ is_float =}
    {=# is_float =}
    dtostrf(metric_{= name =}, {= width =}, {= prec =}, requestValue);
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %s}")), ltrim(requestValue));
    {=/ is_float =}
    return true;
}

func set_metric_{= name =}_readed() {
    metric_{= name =}_readed = true;
}

{=/ metrics =}

{=^ low_memory =}
func reportMetric(force bool) bool {
    bool wantSend = false;
    int total_length = 0;
    wantSendData[0] = '{';
    total_length += 1;

    {=# metrics =}
    {=# auto =}
    if ((is_valid_float(metric_{= name =}, {= min =}, {= max =}) && abs(last_metric_{= name =} - metric_{= name =}) > metric_{= name =}_threshold) || force) {
        tempSendData[0] = '\0';
        if (get_metric_{= name =}(tempSendData)) {
            merge_json(wantSendData, tempSendData, &total_length);
            wantSend = true;
            last_metric_{= name =} = metric_{= name =};
        }
    }

    {=/ auto =}
    {=/ metrics =}
    if (wantSend) {
        wantSendData[total_length-1] = '}';
        wantSendData[total_length] = '\0';

        send_packet_1(TELEMETRY, wantSendData, total_length);
        return true;
    }
    return false;
}

func reportAttribute(force bool) bool {
    int total_length = 0;
    bool wantSend = false;
    wantSendData[0] = '{';
    total_length += 1;

    {=# attrs =}
    if (last_attr_{= name =} != attr_{= name =} || force || attr_{= name =}_force) {
        tempSendData[0] = '\0';
        if (get_attr_{= name =}(tempSendData)) {
            merge_json(wantSendData, tempSendData, &total_length);
            wantSend = true;
            last_attr_{= name =} = attr_{= name =};
            attr_{= name =}_force = false;
        }
    }

    {=/ attrs =}
    {=# metrics =}
    {=# auto =}
    if (last_metric_{= name =}_threshold != metric_{= name =}_threshold || force || metric_{= name =}_threshold_force) {
        tempSendData[0] = '\0';
        if (get_metric_{= name =}_threshold(tempSendData)) {
            merge_json(wantSendData, tempSendData, &total_length);
            wantSend = true;
            last_metric_{= name =}_threshold = metric_{= name =}_threshold;
            metric_{= name =}_threshold_force = false;
        }
    }

    {=/ auto =}
    {=/ metrics =}
    if (wantSend) {
        wantSendData[total_length-1] = '}';
        wantSendData[total_length] = '\0';

        send_packet_1(ATTRIBUTE, wantSendData, total_length);
        return true;
    }
    return false;
}
{=/ low_memory =}

{=# low_memory =}
{=# has_metric =}
func is_valid_report_metric_index() bool {
    {=# metrics =}
    {=# auto =}
    if (report_metric_index == {= index =}) {
        return true;
    }

    {=/ auto =}
    {=/ metrics =}
    return false;
}

func report_metric_next_index() void {
    for (int i = 0; i < 20; i ++) {
        report_metric_index += 1;
        if (report_metric_index >= 20) {
            report_metric_index = 0;
        }
        if (is_valid_report_metric_index()) {
            break;
        }
    }
}

setup setup_report_metric_index {
    report_metric_next_index();
}

func reportMetric() bool {
    {=# metrics =}
    {=# auto =}
    if (metric_{= name =}_readed && ((is_valid_float(metric_{= name =}, {= min =}, {= max =}) && abs(last_metric_{= name =} - metric_{= name =}) > metric_{= name =}_threshold) || !metric_{= name =}_reported) && report_metric_index == {= index =}) {
        wantSendData[0] = '\0';
        if (get_metric_{= name =}(wantSendData)) {
            send_packet_1(TELEMETRY, wantSendData, get_json_length(wantSendData));
            cache_metric_{= name =} = metric_{= name =};
            return false;
        }
    }

    {=/ auto =}
    {=/ metrics =}
    report_metric_next_index();

    return true;
}

func doneReportMetric() void {
    {=# metrics =}
    {=# auto =}
    if (report_metric_index == {= index =}) {
        last_metric_{= name =} = cache_metric_{= name =};
        metric_{= name =}_reported = true;
        metric_{= name =}_readed = false;
    }

    {=/ auto =}
    {=/ metrics =}
    report_metric_next_index();
}

func setReportMetricAll() void {
    {=# metrics =}
    {=# auto =}
    metric_{= name =}_reported = false;
    {=/ auto =}
    {=/ metrics =}
}

{=/ has_metric =}
func is_valid_report_attr_index() bool {
    {=# attrs =}
    if (report_attr_index == {= index =}) {
        return true;
    }

    {=/ attrs =}
    {=# metrics =}
    {=# auto =}
    if (report_attr_index == {= index =}) {
        return true;
    }

    {=/ auto =}
    {=/ metrics =}
    return false;
}

func report_attr_next_index() void {
    for (int i = 0; i < 20; i ++) {
        report_attr_index += 1;
        if (report_attr_index >= 20) {
            report_attr_index = 0;
        }
        if (is_valid_report_attr_index()) {
            break;
        }
    }
}

{=# has_app =}
setup setup_report_attr_index {
    report_attr_next_index();
}
{=/ has_app =}

func reportAttribute() bool {
    {=# attrs =}
    if ((last_attr_{= name =} != attr_{= name =} || !attr_{= name =}_reported) && report_attr_index == {= index =}) {
        wantSendData[0] = '\0';
        if (get_attr_{= name =}(wantSendData)) {
            send_packet_1(ATTRIBUTE, wantSendData, get_json_length(wantSendData));
            cache_attr_{= name =} = attr_{= name =};
            return false;
        }
    }

    {=/ attrs =}
    {=# metrics =}
    {=# auto =}
    if ((last_metric_{= name =}_threshold != metric_{= name =}_threshold || !metric_{= name =}_threshold_reported) && report_attr_index == {= index =}) {
        wantSendData[0] = '\0';
        if (get_metric_{= name =}_threshold(wantSendData)) {
            send_packet_1(ATTRIBUTE, wantSendData, get_json_length(wantSendData));
            cache_metric_{= name =}_threshold = metric_{= name =}_threshold;
            return false;
        }
    }

    {=/ auto =}
    {=/ metrics =}

    report_attr_next_index();
    return true;
}

func doneReportAttribute() void {
    {=# attrs =}
    if (report_attr_index == {= index =}) {
        last_attr_{= name =} = cache_attr_{= name =};
        attr_{= name =}_reported = true;
    }

    {=/ attrs =}
    {=# metrics =}
    {=# auto =}
    if (report_attr_index == {= index =}) {
        last_metric_{= name =}_threshold = cache_metric_{= name =}_threshold;
        metric_{= name =}_threshold_reported = true;
    }

    {=/ auto =}
    {=/ metrics =}

    report_attr_next_index();
}
{=/ low_memory =}
