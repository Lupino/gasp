import <stdlib.h>
import <stdbool.h>
import <stdint.h>

REQUEST     = 1
RESPONSE    = 2
ATTRIBUTE   = 3
TELEMETRY   = 4
PING        = 5
SUCCESS     = 6
ERROR       = 7
AUTHREQ     = 8
AUTHRES     = 9
TRNS        = 10
CTRLREQ     = 11
CTRLRES     = 12
CTRLREQ1    = 13
DROP        = 14
SWITCH      = 15
SWITCHBEAT  = 16
SYNCTIME    = 17
GETSETTOKEN = 18
REQUEST1    = 19
RESPONSE1   = 20

PACKET_MAGIC_LENGTH = 4
PACKET_TYPE_LENGTH = 1
PACKET_ID_LENGTH = 2
PACKET_CRC_LENGTH = 2
PACKET_LENGTH_LENGTH = 2
PACKET_ADDR_LENGTH = 4

PACKET_BROADCAST_HEAD_LENGTH = PACKET_MAGIC_LENGTH + 2

INIT_CRC = 0x0000

// givelink packet magic
GLP0 = "GLP0"


MINI_RAW_PACKET_LENGTH = PACKET_MAGIC_LENGTH + 1 + 1 + PACKET_ID_LENGTH + PACKET_LENGTH_LENGTH + PACKET_CRC_LENGTH + PACKET_TYPE_LENGTH

func_raw gen_packet_raw {
void gen_packet_raw(
        uint8_t * pkt,
        const uint8_t * key, const uint16_t keyLen,
        const uint8_t * token, const uint16_t tokenLen,
        const uint16_t id, const uint8_t tp,
        const uint8_t * data, const uint16_t dataLen) {
    givelink_raw_set_magic(pkt);
    givelink_raw_set_key(pkt, key, keyLen);
    givelink_raw_set_token(pkt, token, tokenLen);
    givelink_raw_set_id(pkt, id);
    givelink_raw_set_type(pkt, tp);
    givelink_raw_set_data(pkt, data, dataLen);
    givelink_raw_set_crc16(pkt);

}
}

func_raw gen_packet_no_data {
void gen_packet_no_data(
        uint8_t * pkt,
        const uint8_t * key, const uint16_t keyLen,
        const uint8_t * token, const uint16_t tokenLen,
        const uint16_t id, const uint8_t tp) {
    gen_packet_raw(pkt, key, keyLen, token, tokenLen, id, tp, NULL, 0);
}
}

func_raw gen_packet_with_addr {
void gen_packet_with_addr(
        uint8_t * pkt,
        const uint8_t * addr,
        const uint16_t id, const uint8_t tp,
        const uint8_t * data, const uint16_t dataLen) {
    gen_packet_raw(pkt, addr, PACKET_ADDR_LENGTH, NULL, 0, id, tp, data, dataLen);
}
}

func_raw gen_packet_with_addr_no_data {
void gen_packet_with_addr_no_data(
        uint8_t * pkt,
        const uint8_t * addr,
        const uint16_t id, const uint8_t tp) {
    gen_packet_with_addr(pkt, addr, id, tp, NULL, 0);
}
}


func_raw givelink_raw_get_header_length {
uint16_t givelink_raw_get_header_length(const uint8_t * payload, const uint16_t size) {
    if (size < MINI_RAW_PACKET_LENGTH) {
        return 0;
    }
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    const uint16_t keyLen = (const uint16_t)payload[headerLen];
    headerLen = headerLen + 1 + keyLen;
    if (size <= headerLen) {
        return 0;
    }
    const uint16_t tokenLen = (const uint16_t)payload[headerLen];
    headerLen = headerLen + 1 + tokenLen + PACKET_ID_LENGTH + PACKET_LENGTH_LENGTH + PACKET_CRC_LENGTH;
    if (size < headerLen) {
        return 0;
    }
    return headerLen;
}
}

func_raw givelink_raw_get_data_length0 {
uint16_t givelink_raw_get_data_length0(const uint8_t * payload, const uint16_t headerLen) {
    const uint16_t pos = headerLen - PACKET_CRC_LENGTH - PACKET_LENGTH_LENGTH;
    return givelink_bin2uint16(payload[pos], payload[pos+1]);
}
}

func_raw givelink_raw_check_crc16 {
bool givelink_raw_check_crc16(uint8_t * payload, const uint16_t length, const uint16_t headerLen) {
    const uint16_t pos = headerLen - PACKET_CRC_LENGTH;
    const uint8_t crch = payload[pos];
    const uint8_t crcl = payload[pos+1];
    const uint16_t crc0 = givelink_bin2uint16(crch, crcl);

    payload[pos] = 0x00;
    payload[pos+1] = 0x00;

    const uint16_t crc = givelink_crc16(payload, length, INIT_CRC);

    payload[pos] = crch;
    payload[pos+1] = crcl;

    return crc == crc0;
}
}

func_raw givelink_raw_recv {
bool givelink_raw_recv(uint8_t * payload, uint16_t * length, const uint8_t c) {
    uint16_t size = *length;
    bool recved = false;
    payload[size] = c;
    size = size + 1;
    if (givelink_discover_magic(payload, size)) {
        uint16_t headerLen = givelink_raw_get_header_length(payload, size);
        if (headerLen > 0) {
            uint16_t dataLen = givelink_raw_get_data_length0(payload, headerLen);
            if (size >= headerLen + dataLen) {
                if (givelink_raw_check_crc16(payload, size, headerLen)) {
                    recved = true;
                } else {
                    givelink_shift_data(payload, &size);
                }
            }
        }
    } else {
        givelink_shift_data(payload, &size);
    }

    *length = size;
    return recved;
}

}

func_raw givelink_raw_set_key {
void givelink_raw_set_key(uint8_t * payload, const uint8_t * key, const uint16_t key_len) {
    payload[PACKET_MAGIC_LENGTH] = (const uint8_t)key_len;
    if (key_len > 0) {
        memcpy(payload + PACKET_MAGIC_LENGTH + 1, key, key_len);
    }
}

}

func_raw givelink_raw_set_token {
void givelink_raw_set_token(uint8_t * payload, const uint8_t * token, const uint16_t token_len) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen];
    payload[headerLen] = (const uint8_t)token_len;
    if (token_len > 0) {
        memcpy(payload + headerLen + 1, token, token_len);
    }
}

}

func_raw givelink_raw_set_id {
void givelink_raw_set_id(uint8_t * payload, const uint16_t id) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + keyLen
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + tokenLen

    uint8_t h;
    uint8_t l;

    givelink_uint2bin16(id, &h, &l);

    payload[headerLen]     = h;
    payload[headerLen + 1] = l;
}
}

func_raw givelink_raw_set_type {
void givelink_raw_set_type(uint8_t * payload, const uint8_t type) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + keyLen
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + tokenLen
    headerLen = headerLen + PACKET_ID_LENGTH + PACKET_LENGTH_LENGTH + PACKET_CRC_LENGTH;
    payload[headerLen] = type;
}
}

func_raw givelink_raw_set_data {
void givelink_raw_set_data(uint8_t * payload, const uint8_t * data, const uint16_t length) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + keyLen
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + tokenLen
    headerLen = headerLen + PACKET_ID_LENGTH;

    uint8_t h;
    uint8_t l;

    givelink_uint2bin16(length + 1, &h, &l);

    payload[headerLen]     = h;
    payload[headerLen + 1] = l;

    headerLen = headerLen + PACKET_LENGTH_LENGTH + PACKET_CRC_LENGTH + PACKET_TYPE_LENGTH;

    if (length > 0) {
        memcpy(payload + headerLen, data, length);
    }
}

}

func_raw givelink_raw_get_length {
uint16_t givelink_raw_get_length(const uint8_t * payload) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + keyLen
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + tokenLen
    headerLen = headerLen + PACKET_ID_LENGTH; // + idLen
    headerLen = headerLen + givelink_bin2uint16(payload[headerLen], payload[headerLen+1]); // dataLen
    headerLen = headerLen + PACKET_LENGTH_LENGTH + PACKET_CRC_LENGTH;
    return headerLen;
}

}

func_raw givelink_raw_set_crc16 {
void givelink_raw_set_crc16(uint8_t * payload) {
    const uint16_t size = givelink_raw_get_length(payload);
    const uint16_t headerLen = givelink_raw_get_header_length(payload, size);
    const uint16_t pos = headerLen - PACKET_CRC_LENGTH;
    payload[pos]     = 0;
    payload[pos + 1] = 0;

    const uint16_t crc = givelink_crc16(payload, size, INIT_CRC);

    uint8_t h;
    uint8_t l;

    givelink_uint2bin16(crc, &h, &l);

    payload[pos]     = h;
    payload[pos + 1] = l;
}

}

func_raw givelink_raw_get_type {
uint8_t givelink_raw_get_type(const uint8_t * payload) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + keyLen
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + tokenLen
    headerLen = headerLen + PACKET_ID_LENGTH + PACKET_LENGTH_LENGTH + PACKET_CRC_LENGTH;
    return payload[headerLen];
}

}

func_raw givelink_raw_get_data {
void givelink_raw_get_data(const uint8_t * payload, uint8_t * data, uint16_t *dataLen) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + keyLen
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + tokenLen
    headerLen = headerLen + PACKET_ID_LENGTH;

    *dataLen = givelink_bin2uint16(payload[headerLen], payload[headerLen+1]) - 1;

    headerLen = headerLen + PACKET_LENGTH_LENGTH + PACKET_CRC_LENGTH + PACKET_TYPE_LENGTH;

    if (*dataLen > 0) {
        memcpy(data, payload + headerLen, *dataLen);
    }
}

}

func_raw givelink_raw_get_id {
uint16_t givelink_raw_get_id(const uint8_t * payload) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + keyLen
    headerLen = headerLen + 1 + (const uint16_t)payload[headerLen]; // + tokenLen
    return givelink_bin2uint16(payload[headerLen], payload[headerLen+1]);
}


}

func_raw givelink_raw_get_key {
void givelink_raw_get_key(const uint8_t * payload, uint8_t * key, uint16_t * key_len) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    *key_len = (uint16_t)payload[headerLen];
    if (*key_len > 0) {
        memcpy(key, payload + headerLen + 1, *key_len);
    }
}


}

func_raw givelink_raw_get_token {
void givelink_raw_get_token(const uint8_t * payload, uint8_t * token, uint16_t * token_len) {
    uint16_t headerLen = PACKET_MAGIC_LENGTH;
    headerLen = headerLen + 1 + (uint16_t)payload[headerLen];
    *token_len = (uint16_t)payload[headerLen];
    if (*token_len > 0) {
        memcpy(token, payload + headerLen + 1, *token_len);
    }
}

}

func_raw givelink_raw_set_magic {
void givelink_raw_set_magic(uint8_t * payload) {
    memcpy(payload, (uint8_t *)GLP0, PACKET_MAGIC_LENGTH);
}
}

raw crc_tab16 {
#if !defined(__SAM3X8E__)
#if defined(__AVR__ ) || defined(__IMXRT1052__) || defined(__IMXRT1062__) || defined(ARDUINO_ARCH_STM32F1)
#include <avr/pgmspace.h>
#elif defined(ARDUINO_ARCH_STM8)
#elif !defined(__arm__)
#include <pgmspace.h>
#endif
#endif

#if defined(__arm__) || defined(ARDUINO_ARCH_STM8)
const uint16_t crc_tab16[256] = { // }
#else
const uint16_t crc_tab16[256] PROGMEM = {
#endif
    0x0000, 0xc0c1, 0xc181, 0x0140
  , 0xc301, 0x03c0, 0x0280, 0xc241
  , 0xc601, 0x06c0, 0x0780, 0xc741
  , 0x0500, 0xc5c1, 0xc481, 0x0440
  , 0xcc01, 0x0cc0, 0x0d80, 0xcd41
  , 0x0f00, 0xcfc1, 0xce81, 0x0e40
  , 0x0a00, 0xcac1, 0xcb81, 0x0b40
  , 0xc901, 0x09c0, 0x0880, 0xc841
  , 0xd801, 0x18c0, 0x1980, 0xd941
  , 0x1b00, 0xdbc1, 0xda81, 0x1a40
  , 0x1e00, 0xdec1, 0xdf81, 0x1f40
  , 0xdd01, 0x1dc0, 0x1c80, 0xdc41
  , 0x1400, 0xd4c1, 0xd581, 0x1540
  , 0xd701, 0x17c0, 0x1680, 0xd641
  , 0xd201, 0x12c0, 0x1380, 0xd341
  , 0x1100, 0xd1c1, 0xd081, 0x1040
  , 0xf001, 0x30c0, 0x3180, 0xf141
  , 0x3300, 0xf3c1, 0xf281, 0x3240
  , 0x3600, 0xf6c1, 0xf781, 0x3740
  , 0xf501, 0x35c0, 0x3480, 0xf441
  , 0x3c00, 0xfcc1, 0xfd81, 0x3d40
  , 0xff01, 0x3fc0, 0x3e80, 0xfe41
  , 0xfa01, 0x3ac0, 0x3b80, 0xfb41
  , 0x3900, 0xf9c1, 0xf881, 0x3840
  , 0x2800, 0xe8c1, 0xe981, 0x2940
  , 0xeb01, 0x2bc0, 0x2a80, 0xea41
  , 0xee01, 0x2ec0, 0x2f80, 0xef41
  , 0x2d00, 0xedc1, 0xec81, 0x2c40
  , 0xe401, 0x24c0, 0x2580, 0xe541
  , 0x2700, 0xe7c1, 0xe681, 0x2640
  , 0x2200, 0xe2c1, 0xe381, 0x2340
  , 0xe101, 0x21c0, 0x2080, 0xe041
  , 0xa001, 0x60c0, 0x6180, 0xa141
  , 0x6300, 0xa3c1, 0xa281, 0x6240
  , 0x6600, 0xa6c1, 0xa781, 0x6740
  , 0xa501, 0x65c0, 0x6480, 0xa441
  , 0x6c00, 0xacc1, 0xad81, 0x6d40
  , 0xaf01, 0x6fc0, 0x6e80, 0xae41
  , 0xaa01, 0x6ac0, 0x6b80, 0xab41
  , 0x6900, 0xa9c1, 0xa881, 0x6840
  , 0x7800, 0xb8c1, 0xb981, 0x7940
  , 0xbb01, 0x7bc0, 0x7a80, 0xba41
  , 0xbe01, 0x7ec0, 0x7f80, 0xbf41
  , 0x7d00, 0xbdc1, 0xbc81, 0x7c40
  , 0xb401, 0x74c0, 0x7580, 0xb541
  , 0x7700, 0xb7c1, 0xb681, 0x7640
  , 0x7200, 0xb2c1, 0xb381, 0x7340
  , 0xb101, 0x71c0, 0x7080, 0xb041
  , 0x5000, 0x90c1, 0x9181, 0x5140
  , 0x9301, 0x53c0, 0x5280, 0x9241
  , 0x9601, 0x56c0, 0x5780, 0x9741
  , 0x5500, 0x95c1, 0x9481, 0x5440
  , 0x9c01, 0x5cc0, 0x5d80, 0x9d41
  , 0x5f00, 0x9fc1, 0x9e81, 0x5e40
  , 0x5a00, 0x9ac1, 0x9b81, 0x5b40
  , 0x9901, 0x59c0, 0x5880, 0x9841
  , 0x8801, 0x48c0, 0x4980, 0x8941
  , 0x4b00, 0x8bc1, 0x8a81, 0x4a40
  , 0x4e00, 0x8ec1, 0x8f81, 0x4f40
  , 0x8d01, 0x4dc0, 0x4c80, 0x8c41
  , 0x4400, 0x84c1, 0x8581, 0x4540
  , 0x8701, 0x47c0, 0x4680, 0x8641
  , 0x8201, 0x42c0, 0x4380, 0x8341
  , 0x4100, 0x81c1, 0x8081, 0x4040
};
}


// uint16_t givelink_crc16(const uint8_t *input_str, const size_t num_bytes, const uint16_t init_crc);
//
// The function givelink_crc16() calculates the 16 bits CRC16 in one pass for a byte
// string of which the beginning has been passed to the function. The number of
// bytes to check is also a parameter. The number of the bytes in the string is
// limited by the constant SIZE_MAX.


func_raw givelink_crc16 {
uint16_t givelink_crc16(const uint8_t *input_str, const size_t num_bytes, const uint16_t init_crc) {

  uint16_t crc;
  const uint8_t *ptr;
  size_t a;

  crc = init_crc;
  ptr = input_str;

  if ( ptr != NULL ) for (a=0; a<num_bytes; a++) {

    #if defined(__arm__) || defined(ARDUINO_ARCH_STM8)
    crc = (crc >> 8) ^ crc_tab16[ (crc ^ (uint16_t) *ptr++) & 0x00FF ];
    #else
    crc = (crc >> 8) ^ pgm_read_word(&crc_tab16[ (crc ^ (uint16_t) *ptr++) & 0x00FF ]);
    #endif
  }

  return crc;

}  /* givelink_crc16 */


}

func_raw givelink_bin2uint16 {
uint16_t givelink_bin2uint16(const uint8_t h, const uint8_t l) {
    return ((h << 8) & 0xff00) + (l & 0xff);
}

}

func_raw givelink_uint2bin16 {
void givelink_uint2bin16(const uint16_t src, uint8_t *h, uint8_t *l) {
    *h = (uint8_t)(src >> 8);
    *l = (uint8_t)src;
}

}

func_raw givelink_discover_magic {
bool givelink_discover_magic(const uint8_t * payload, const uint16_t length) {
    if (length < PACKET_MAGIC_LENGTH) {
        return false;
    }
    if (payload[0] == 'G'
            && payload[1] == 'L'
            && payload[2] == 'P'
            && payload[3] == '0') {
        return true;
    }
    return false;
}

}

func_raw givelink_is_broadcast {
bool givelink_is_broadcast(const uint8_t * payload, const uint16_t length) {
    if (length < PACKET_BROADCAST_HEAD_LENGTH) {
        return false;
    }
    if (payload[0] == 'G'
            && payload[1] == 'L'
            && payload[2] == 'P'
            && payload[3] == '0'
            && payload[4] == 0x00
            && payload[5] == 0x00) {
        return true;
    }
    return false;
}

}

func_raw givelink_shift_data_raw {
void givelink_shift_data_raw(uint8_t * payload, const uint16_t length) {
    for (uint16_t i = 0; i < length - 1; i ++) {
        payload[i] = payload[i + 1];
    }
}

}

func_raw givelink_shift_data {
void givelink_shift_data(uint8_t * payload, uint16_t * length) {
    uint16_t headLen = *length;
    while (headLen >= PACKET_MAGIC_LENGTH) {
        givelink_shift_data_raw(payload, headLen);
        headLen -= 1;
        if (givelink_discover_magic(payload, headLen)) {
            break;
        }
    }
    *length = headLen;
}
}
