{{={= =}=}}
{=# has_app =}
import <givelink_raw.h> https://github.com/Lupino/givelink.git
import <jsmn.h> https://github.com/zserge/jsmn.git
GL_SERIAL_availabled_timer_ms unsigned long = 0
GL_SERIAL_received_timer_ms unsigned long = 0
GL_SERIAL_received bool = false
packet_sended bool = true;

loop givelink_loop {
    GL_SERIAL_poll();
    GL_SERIAL_main();
}

func GL_SERIAL_poll {
    if (GL_SERIAL.available() > 0) {
        GL_SERIAL_availabled_timer_ms = get_current_time_ms();
        while (GL_SERIAL.available() > 0) {
            if (GL_SERIAL_received) {
                GL_SERIAL.read();
            } else {
                GL_SERIAL_received = givelink_raw_recv(READED_PAYLOAD, &readedLen, GL_SERIAL.read());
                if (readedLen >= MAX_GL_PAYLOAD_LENGTH) {
                    {=# has_debug =}
                    DEBUG_SERIAL.println(TO_ROM("Error: payload to large"));
                    {=/ has_debug =}
                    givelink_shift_data(READED_PAYLOAD, &readedLen);
                }
            }
        }
    }

    if (GL_SERIAL_received) {
        GL_SERIAL_received = false;
        if (is_self(READED_PAYLOAD, readedLen)) {
            GL_SERIAL_parse(READED_PAYLOAD, readedLen);
        }
        readedLen = 0;
    }
}

func GL_SERIAL_parse(buffer const uint8_t *, len const int) {
    GL_SERIAL_received_timer_ms = get_current_time_ms();
    givelink_type = givelink_raw_get_type(buffer);
    givelink_id = givelink_raw_get_id(buffer);
    givelink_raw_get_data(buffer, PACKET_DATA, &packet_data_length);
    PACKET_DATA[packet_data_length] = '\0';
    {=# ctrl_mode =}
    packet_sended = false;
    {=/ ctrl_mode =}
    {=# has_debug =}
    DEBUG_SERIAL.print(TO_ROM("Recv Id: "));
    DEBUG_SERIAL.print(givelink_id);
    DEBUG_SERIAL.print(TO_ROM(" Type: "));
    DEBUG_PRINT_TYPE(givelink_type);
    if (packet_data_length > 0) {
        DEBUG_SERIAL.print(TO_ROM(" Data Length: "));
        DEBUG_SERIAL.print(packet_data_length);
        DEBUG_SERIAL.print(TO_ROM(" Data: "));
        for (uint16_t i = 0; i < packet_data_length; i ++) {
            DEBUG_SERIAL.write(PACKET_DATA[i]);
        }
        DEBUG_SERIAL.print(TO_ROM(" Data HEX: "));
        DEBUG_PRINT_HEX(PACKET_DATA, packet_data_length);
    } else {
        DEBUG_SERIAL.println();
    }
    DEBUG_PRINT_HEX(buffer, len);

    {=/ has_debug =}
    if (givelink_type == AUTHRES) {
        {=# app =}
        for (int i = 0; i < {= addr_len =}; i ++) {
            givelink_addr[i] = PACKET_DATA[i];
        }
        {=/ app =}
        givelink_authed = true;
        save_addr();
        {=# low_memory =}
        incrLastPayloadId();
        {=/ low_memory =}
    }
    if (givelink_type == GETSETTOKEN) {
        {=# production =}
        if (packet_data_length > 0) {
            save_token();
        }
        {=/ production =}
        send_token();
    }
    if (givelink_type == REQUEST) {
        wantSendData[0] = '\0';
        bool ret = processRequest((const char *)PACKET_DATA, packet_data_length, wantSendData);
        if (wantSendData[0] == '\0') {
            if (ret) {
                sprintf(wantSendData, FROM_ROM(TO_ROM("{\"result\": \"OK\"}")));
            } else {
                sprintf(wantSendData, FROM_ROM(TO_ROM("{\"err\": \"not support\"}")));
            }
        }
        send_packet_rsp(wantSendData);
    }
    if (givelink_type == SUCCESS) {
        ping_failed = 0;
        if (lastPayloadId == ping_packet_id) {
            ping_timer_ms = get_cache_time_ms();
            {=# low_memory =}
            incrLastPayloadId();
            {=/ low_memory =}
        }
        {=^ low_memory =}
        {=# auto_retry =}
        {=# ctrl_mode =}
        if (lastPayloadId == report_attr_packet_id) {
            need_retry = false;
        }
        if (lastPayloadId == report_metric_packet_id) {
            need_retry = false;
        }
        {=/ ctrl_mode =}
        {=^ ctrl_mode =}
        need_retry = false;
        {=/ ctrl_mode =}
        {=/ auto_retry =}
        {=/ low_memory =}
        {=# low_memory =}
        if (lastPayloadId == report_attr_packet_id) {
            doneReportAttribute();
            incrLastPayloadId();
        }
        {=# has_metric =}
        if (lastPayloadId == report_metric_packet_id) {
            doneReportMetric();
            incrLastPayloadId();
        }
        {=/ has_metric =}
        {=/ low_memory =}
    }
    {=# has_timer =}
    if (givelink_type == SYNCTIME) {
        sys_timer_s = (uint32_t)atol((const char *)PACKET_DATA);
        sys_timer_synced_ms = get_cache_time_ms();
    }
    {=/ has_timer =}
    {=# ctrl_mode =}
    if (givelink_type == CTRLREQ) {
        mainAction();
        send_packet_0(CTRLRES);
    }
    if (givelink_type == CTRLREQ1) {
        mainAction();
        if (report_timer_ms + REPORT_DELAY_MS < get_cache_time_ms()) {
            send_packet_0(PING);
        }
        send_packet_0(CTRLRES);
    }
    {=/ ctrl_mode =}
}

func GL_SERIAL_main {
    if (!givelink_authed) {
        requireReportAttribute = true;
        if (auth_timer_ms + AUTH_DELAY_MS < get_cache_time_ms()) {
            {=# ctrl_mode =}
            packet_sended = false;
            {=/ ctrl_mode =}
            send_packet_0(AUTHREQ);
            auth_timer_ms = get_cache_time_ms();
        }
    {=^ ctrl_mode =}
    } else {
        mainAction();
    {=/ ctrl_mode =}
    }
}
{=/ has_app =}

{=# has_debug =}
setup w_setup_debug_print {
    DEBUG_SERIAL.println(TO_ROM("Setup"));
}
{=/ has_debug =}

current_time_ms unsigned long = 0

func get_current_time_ms() unsigned long {
    return millis();
}

loop get_current_time_loop {
    current_time_ms = get_current_time_ms();
}

auth_timer_ms unsigned long = 0

AUTH_DELAY_MS = 1000
PING_DELAY_MS = 300000
MAX_PING_FAILED = 10
MAX_GL_PAYLOAD_LENGTH = {= max_gl_len =}
MAX_BUFFER_LENGTH = {= max_buf_len =}
MAX_NUM_TOKENS = 12
MAX_REQUEST_VALUE_LENGTH = {= max_req_len =}
MAX_TMPL_LENGTH = {= max_tpl_len =}

ping_timer_ms  unsigned long = 0
ping_packet_id uint16_t = 0
ping_failed uint8_t = 0

{=# app =}
key[{= key_len =}] const uint8_t = {{= key_hex_array =}}
{=# production =}
token[{= token_len =}] uint8_t
addr[{= addr_len =}] uint8_t
{=/ production =}
{=^ production =}
token[{= token_len =}] const uint8_t = {{= token_hex_array =}}
addr[{= addr_len =}] uint8_t = {{= addr_hex_array =}}
{=/ production =}

func load_addr() {
    for (int i = 0; i < {= addr_len =}; i ++) {
        givelink_addr[i] = STROAGE_READ({= addr_addr =} + i);
    }
    givelink_authed = true;
}

func setup_givelink {
    {=# production =}
    for (int i = 0; i < {= token_len =}; i ++) {
        token[i] = STROAGE_READ({= token_addr =} + i);
    }
    {=/ production =}
    {=# production =}
    load_addr();
    {=/ production =}
}

setup setup_givelink {
    setup_givelink();
}

func save_addr {
    {=# production =}
    for (int i = 0; i < {= addr_len =}; i ++) {
        STROAGE_WRITE({= addr_addr =} + i, PACKET_DATA[i]);
    }
    STROAGE_COMMIT();
    {=/ production =}
}

func save_token {
    for (int i = 0; i < {= token_len =}; i ++) {
        STROAGE_WRITE({= token_addr =} + i, PACKET_DATA[i]);
    }
    STROAGE_COMMIT();
    setup_givelink();
}


func send_token() {
    int idx = 0;
    uint8_t *buf = (uint8_t *) wantSendData;
    buf[idx] = {= key_len =};
    idx ++;
    for (int i = 0; i < {= key_len =}; i ++) {
        buf[idx] = key[i];
        idx ++;
    }
    buf[idx] = {= token_len =};
    idx ++;
    for (int i = 0; i < {= token_len =}; i ++) {
        buf[idx] = token[i];
        idx ++;
    }

    givelink_type = GETSETTOKEN;
    memcpy(PACKET_DATA, buf, idx);
    packet_data_length = idx;
    send_packet();
}
{=/ app =}

givelink_authed bool = true
givelink_type uint8_t
packet_data[MAX_BUFFER_LENGTH] uint8_t
PACKET_DATA = packet_data
packet_data_length uint16_t
givelink_addr[4] uint8_t
givelink_id uint16_t

lastPayloadId uint16_t = 100
readedLen uint16_t = 0
readedPayload[MAX_GL_PAYLOAD_LENGTH] uint8_t
READED_PAYLOAD = readedPayload
report_attr_packet_id uint16_t = 0
report_metric_packet_id uint16_t = 0
report_timer_ms unsigned long = 4000
REPORT_DELAY_MS = 10
{=# low_memory =}
report_attr_index int = 0
report_metric_index int = 0
{=/ low_memory =}
{=^ low_memory =}
sendedPayload[MAX_GL_PAYLOAD_LENGTH] uint8_t
{=# auto_retry =}
retryPayload[MAX_GL_PAYLOAD_LENGTH] uint8_t
retryLen uint16_t = 0
need_retry bool = false
{=/ auto_retry =}
{=/ low_memory =}


requestJsmnParser jsmn_parser
requestJsmnTokens[MAX_NUM_TOKENS] jsmntok_t
requestValue[MAX_REQUEST_VALUE_LENGTH] char
wantSendData[MAX_BUFFER_LENGTH] char
{=^ low_memory =}
tempSendData[MAX_TMPL_LENGTH] char
{=/ low_memory =}
wantSendDataTpl[MAX_TMPL_LENGTH] char

METRIC_DELAY_MS = 1800000
metric_timer_ms unsigned long = 0
requireReportAttribute bool = true
requireReportMetric bool = true


func mainAction() void {
    if (report_timer_ms + REPORT_DELAY_MS > get_cache_time_ms()) {
        return;
    }

    if (ping_failed > MAX_PING_FAILED) {
        PING_FAILED_CB();
    }

    {=# low_memory =}
    if (!reportAttribute()) {
        ping_failed += 1;
        return;
    }

    {=# has_metric =}
    if (reportMetric()) {
        if (metric_timer_ms + METRIC_DELAY_MS < get_cache_time_ms()) {
            setReportMetricAll();
        }
    } else {
        ping_failed += 1;
        metric_timer_ms = get_cache_time_ms();
        return;
    }

    {=/ has_metric =}
    {=/ low_memory =}
    {=^ low_memory =}
    {=# auto_retry =}
    if (need_retry) {
        report_timer_ms = get_cache_time_ms();
        send_packet_raw(retryPayload, retryLen);
        return;
    }

    {=/ auto_retry =}
    if (reportAttribute(requireReportAttribute)) {
        requireReportAttribute = false;
        return;
    }

    {=# has_metric =}
    if (metric_timer_ms + METRIC_DELAY_MS < get_cache_time_ms()) {
        requireReportMetric = true;
    }

    if (reportMetric(requireReportMetric)) {
        metric_timer_ms = get_cache_time_ms();
        requireReportMetric = false;
        return;
    }

    {=/ has_metric =}
    {=/ low_memory =}
    if (ping_timer_ms + PING_DELAY_MS < get_cache_time_ms()) {
        send_packet_0(PING);
        ping_failed += 1;
    }

    {=# has_timer =}
    if (sys_timer_s < 1000) {
        send_packet_0(SYNCTIME);
    }

    if (sys_timer_synced_ms + SYNCTIME_DELAY_MS < get_cache_time_ms()) {
        send_packet_0(SYNCTIME);
    }
    {=/ has_timer =}
}

func PING_FAILED_CB() void {}

func send_packet_raw(buf uint8_t *, length uint16_t) void {
    delay(5);
    for (uint16_t i = 0; i < length; i ++) {
        GL_SERIAL.write(buf[i]);
    }
    GL_SERIAL.write('\r');
    GL_SERIAL.write('\n');
    GL_SERIAL.flush();
    {=# has_debug =}
    DEBUG_PRINT_HEX(buf, length);
    {=/ has_debug =}
}


func gen_packet(pkt uint8_t *) {
    givelink_raw_set_magic(pkt);
    if (givelink_authed) {
        givelink_raw_set_key(pkt, givelink_addr, 4);
        givelink_raw_set_token(pkt, NULL, 0);
    } else {
        {=# app =}
        givelink_raw_set_key(pkt, key, {= key_len =});
        givelink_raw_set_token(pkt, token, {= token_len =});
        {=/ app =}
    }
    givelink_raw_set_id(pkt, givelink_id);
    givelink_raw_set_type(pkt, givelink_type);
    givelink_raw_set_data(pkt, PACKET_DATA, packet_data_length);
    givelink_raw_set_crc16(pkt);
}

func is_self(buffer const uint8_t *, len const int) bool {
    givelink_raw_get_key(buffer, PACKET_DATA, &packet_data_length);

    {=# app =}
    if (packet_data_length == {= addr_len =} && equal(PACKET_DATA, givelink_addr, packet_data_length)) {
        return true;
    }

    if (packet_data_length == {= key_len =} && equal(PACKET_DATA, key, packet_data_length)) {
        givelink_raw_get_token(buffer, PACKET_DATA, &packet_data_length);
        if (packet_data_length == {= token_len =} && equal(PACKET_DATA, token, packet_data_length)) {
            return true;
        }
    }
    {=/ app =}

    return false;
}

func DEBUG_PRINT_TYPE(type uint8_t) {
    if (type == REQUEST) {
        DEBUG_SERIAL.print("REQUEST");
    } else if (type == RESPONSE) {
        DEBUG_SERIAL.print("RESPONSE");
    } else if (type == ATTRIBUTE) {
        DEBUG_SERIAL.print("ATTRIBUTE");
    } else if (type == TELEMETRY) {
        DEBUG_SERIAL.print("TELEMETRY");
    } else if (type == PING) {
        DEBUG_SERIAL.print("PING");
    } else if (type == SUCCESS) {
        DEBUG_SERIAL.print("SUCCESS");
    } else if (type == ERROR) {
        DEBUG_SERIAL.print("ERROR");
    } else if (type == AUTHREQ) {
        DEBUG_SERIAL.print("AUTHREQ");
    } else if (type == AUTHRES) {
        DEBUG_SERIAL.print("AUTHRES");
    } else if (type == TRNS) {
        DEBUG_SERIAL.print("TRNS");
    } else if (type == CTRLREQ) {
        DEBUG_SERIAL.print("CTRLREQ");
    } else if (type == CTRLRES) {
        DEBUG_SERIAL.print("CTRLRES");
    } else if (type == CTRLREQ1) {
        DEBUG_SERIAL.print("CTRLREQ1");
    } else if (type == DROP) {
        DEBUG_SERIAL.print("DROP");
    } else if (type == SWITCH) {
        DEBUG_SERIAL.print("SWITCH");
    } else if (type == SWITCHBEAT) {
        DEBUG_SERIAL.print("SWITCHBEAT");
    } else if (type == SYNCTIME) {
        DEBUG_SERIAL.print("SYNCTIME");
    } else if (type == GETSETTOKEN) {
        DEBUG_SERIAL.print("GETSETTOKEN");
    }
}

func DEBUG_PRINT_HEX(v const uint8_t *, len int) {
    for (int i=0; i< len; i++) {
        if (v[i] < 16) {
            DEBUG_SERIAL.print("0");
        }
        DEBUG_SERIAL.print(v[i], HEX);
    }
    DEBUG_SERIAL.println();
}

func send_packet() void {
    {=# ctrl_mode =}
    if (packet_sended) {
        return;
    }
    packet_sended = true;
    {=/ ctrl_mode =}
    {=# has_debug =}
    DEBUG_SERIAL.print(TO_ROM("Send Id: "));
    DEBUG_SERIAL.print(givelink_id);
    DEBUG_SERIAL.print(TO_ROM(" Type: "));
    DEBUG_PRINT_TYPE(givelink_type);
    if (packet_data_length > 0) {
        DEBUG_SERIAL.print(TO_ROM(" Data Length: "));
        DEBUG_SERIAL.print(packet_data_length);
        DEBUG_SERIAL.print(TO_ROM(" Data: "));
        for (uint16_t i = 0; i < packet_data_length; i ++) {
            DEBUG_SERIAL.write(PACKET_DATA[i]);
        }
        DEBUG_SERIAL.print(TO_ROM(" Data HEX: "));
        DEBUG_PRINT_HEX(PACKET_DATA, packet_data_length);
    } else {
        DEBUG_SERIAL.println();
    }
    {=/ has_debug =}
    {=# low_memory =}
    gen_packet(READED_PAYLOAD);
    send_packet_raw(READED_PAYLOAD, givelink_raw_get_length(READED_PAYLOAD));
    {=/ low_memory =}
    {=^ low_memory =}
    {=# auto_retry =}
    if (givelink_type == ATTRIBUTE || givelink_type == TELEMETRY) {
        gen_packet(retryPayload);
        retryLen = , givelink_raw_get_length(retryPayload);
        need_retry = true;

        send_packet_raw(retryPayload, retryLen);
    } else {
        gen_packet(sendedPayload);
        send_packet_raw(sendedPayload, givelink_raw_get_length(sendedPayload));
    }
    {=/ auto_retry =}
    {=^ auto_retry =}
    gen_packet(sendedPayload);
    send_packet_raw(sendedPayload, givelink_raw_get_length(sendedPayload));
    {=/ auto_retry =}
    {=/ low_memory =}
}

func send_packet_0(type const uint8_t) void {
    next_packet(type);
    send_packet();
}

func send_packet_1(type const uint8_t, data_ const char *, length const int) void {
    next_packet(type);
    packet_data_length = length;
    memcpy(PACKET_DATA, data_, length);
    send_packet();
}

func send_packet_rsp(data_ const char *) void {
    givelink_type = RESPONSE;
    packet_data_length = get_json_length(data_);
    memcpy(PACKET_DATA, (const uint8_t *)data_, packet_data_length);
    send_packet();
}

func next_packet(type const uint8_t) void {
    if (type == PING) {
        ping_packet_id = lastPayloadId;
        report_timer_ms = get_cache_time_ms();
    }

    if (type == ATTRIBUTE) {
        report_attr_packet_id = lastPayloadId;
        report_timer_ms = get_cache_time_ms();
    }

    if (type == TELEMETRY) {
        report_metric_packet_id = lastPayloadId;
        report_timer_ms = get_cache_time_ms();
    }

    {=# has_timer =}
    if (type == SYNCTIME) {
        report_timer_ms = get_cache_time_ms();
    }
    {=/ has_timer =}

    givelink_id = lastPayloadId;
    givelink_type = type;
    packet_data_length = 0;
    {=^ low_memory =}
    incrLastPayloadId();
    {=/ low_memory =}
}

func incrLastPayloadId() {
    lastPayloadId ++;
}

{=# attrs =}

attr_{= name =} {= type =} = {= default =}
cache_attr_{= name =} {= type =} = {= default =}
last_attr_{= name =} {= type =} = {= default =}
attr_{= name =}_force bool = true
attr_{= name =}_reported bool = false

{=# has_app =}
{=# keep =}
setup setup_attr_{= name =} {
    {=# onebyte =}
    attr_{= name =} = STROAGE_READ({= addr =});
    {=/ onebyte =}
    {=^ onebyte =}
    STROAGE_GET({= addr =}, attr_{= name =});
    {=/ onebyte =}
    {=# is_float =}
    if (!is_valid_float(attr_{= name =}, {= scaled_min =}, {= scaled_max =})) {
    {=/ is_float =}
    {=^ is_float =}
    {=# uncheckmin =}
    if (attr_{= name =} > {= scaled_max =}) {
    {=/ uncheckmin =}
    {=^ uncheckmin =}
    if (attr_{= name =} < {= scaled_min =} || attr_{= name =} > {= scaled_max =}) {
    {=/ uncheckmin =}
    {=/ is_float =}
        attr_{= name =} = {= default =};
    }
}
{=/ keep =}
{=/ has_app =}

func set_attr_{= name =}_raw(unscaled_value {= type =}) void {
    attr_{= name =}_force = true;
    attr_{= name =} = unscaled_value * {= scale =};
    {=# keep =}
    {=# onebyte =}
    STROAGE_WRITE({= addr =}, attr_{= name =});
    {=/ onebyte =}
    {=^ onebyte =}
    STROAGE_PUT({= addr =}, attr_{= name =});
    {=/ onebyte =}
    STROAGE_COMMIT();
    {=/ keep =}
}


func set_attr_{= name =}(json const char *, tokens jsmntok_t *, num_tokens int, retval char *) bool {
    if (jsonlookup(json, tokens, num_tokens, FROM_ROM(TO_ROM("data")), requestValue)) {
        {=# is_float =}
        float tmp;
        bool r = prepare_float(&tmp, retval, requestValue, {= min =}, {= max =});
        {=/ is_float =}
        {=^ is_float =}
        long tmp;
        bool r = prepare_long(&tmp, retval, requestValue, {= min =}, {= max =});
        {=/ is_float =}
        if (!r) {
            return false;
        }
        set_attr_{= name =}_raw(({= type =})tmp);
        {=# has_event =}
        {= event =}(({= type =})tmp);
        {=/ has_event =}
    }
    get_attr_{= name =}(retval);
    return true;
}

func get_attr_{= name =}(retval char *) bool {
    {=^ is_float =}
    {=# is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %ld}")), ({= type =})attr_{= name =} / {= scale =});
    {=/ is_long =}
    {=^ is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %d}")), ({= type =})attr_{= name =} / {= scale =});
    {=/ is_long =}
    {=/ is_float =}
    {=# is_float =}
    dtostrf(({= type =})attr_{= name =} / {= scale =}, {= width =}, {= prec =}, requestValue);
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %s}")), ltrim(requestValue));
    {=/ is_float =}
    return true;
}

{=/ attrs =}

{=# metrics =}
metric_{= name =} {= type =} = 0
cache_metric_{= name =} {= type =} = 0
last_metric_{= name =} {= type =} = 0
metric_{= name =}_reported bool = true
metric_{= name =}_readed bool = false

{=# auto =}
metric_{= name =}_threshold {= type =} = {= threshold =}
cache_metric_{= name =}_threshold {= type =} = {= threshold =}
last_metric_{= name =}_threshold {= type =} = {= threshold =}
metric_{= name =}_threshold_force bool = true
metric_{= name =}_threshold_reported bool = false

{=# has_app =}
setup setup_metric_{= name =} {
    {=# onebyte =}
    metric_{= name =}_threshold = STROAGE_READ({= addr =});
    {=/ onebyte =}
    {=^ onebyte =}
    STROAGE_GET({= addr =}, metric_{= name =}_threshold);
    {=/ onebyte =}
    {=# is_float =}
    if (!is_valid_float(metric_{= name =}_threshold, {= min_threshold =}, {= max_threshold =})) {
    {=/ is_float =}
    {=^ is_float =}
    {=# uncheckmin =}
    if (metric_{= name =}_threshold > {= max_threshold =}) {
    {=/ uncheckmin =}
    {=^ uncheckmin =}
    if (metric_{= name =}_threshold < {= min_threshold =} || metric_{= name =}_threshold > {= max_threshold =}) {
    {=/ uncheckmin =}
    {=/ is_float =}
        metric_{= name =}_threshold = {= threshold =};
    }
}
{=/ has_app =}

func set_metric_{= name =}_threshold(json const char *, tokens jsmntok_t *, num_tokens int, retval char *) bool {
    if (jsonlookup(json, tokens, num_tokens, FROM_ROM(TO_ROM("data")), requestValue)) {
        {=# is_float =}
        float tmp;
        bool r = prepare_float(&tmp, retval, requestValue, {= min_threshold =}, {= max_threshold =});
        {=/ is_float =}
        {=^ is_float =}
        long tmp;
        bool r = prepare_long(&tmp, retval, requestValue, {= min_threshold =}, {= max_threshold =});
        {=/ is_float =}
        if (!r) {
            return false;
        }
        metric_{= name =}_threshold = ({= type =})tmp;
        metric_{= name =}_threshold_force = true;
        {=# onebyte =}
        STROAGE_WRITE({= addr =}, metric_{= name =}_threshold);
        {=/ onebyte =}
        {=^ onebyte =}
        STROAGE_PUT({= addr =}, metric_{= name =}_threshold);
        {=/ onebyte =}
        STROAGE_COMMIT();
    }
    get_metric_{= name =}_threshold(retval);
    return true;
}

func get_metric_{= name =}_threshold(retval char *) bool {
    {=^ is_float =}
    {=# is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}_threshold\": %ld}")), metric_{= name =}_threshold);
    {=/ is_long =}
    {=^ is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}_threshold\": %d}")), metric_{= name =}_threshold);
    {=/ is_long =}
    {=/ is_float =}
    {=# is_float =}
    dtostrf(metric_{= name =}_threshold, {= width =}, {= prec =}, requestValue);
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}_threshold\": %s}")), ltrim(requestValue));
    {=/ is_float =}
    return true;
}

{=/ auto =}
func check_metric_{= name =}() bool {
    {=# is_float =}
    return is_valid_float(metric_{= name =}, {= min =}, {= max =});
    {=/ is_float =}
    {=^ is_float =}
    return metric_{= name =} >= {= min =} && metric_{= name =} <= {= max =};
    {=/ is_float =}
}

func get_metric_{= name =}(retval char *) bool {
    if (!check_metric_{= name =}()) {
        return err_invalid(retval);
    }
    {=^ is_float =}
    {=# is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %ld}")), metric_{= name =});
    {=/ is_long =}
    {=^ is_long =}
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %d}")), metric_{= name =});
    {=/ is_long =}
    {=/ is_float =}
    {=# is_float =}
    dtostrf(metric_{= name =}, {= width =}, {= prec =}, requestValue);
    sprintf(retval, FROM_ROM(TO_ROM("{\"{= name =}\": %s}")), ltrim(requestValue));
    {=/ is_float =}
    return true;
}

func set_metric_{= name =}_readed() {
    metric_{= name =}_readed = true;
}

{=/ metrics =}
func processRequest(json const char *, length int, retval char *) bool {
    /* Prepare parser */
    jsmn_init(&requestJsmnParser);
    int num_tokens = jsmn_parse(&requestJsmnParser, json, length, requestJsmnTokens, MAX_NUM_TOKENS);

    if (num_tokens < 0) {
        sprintf(retval, FROM_ROM(TO_ROM("{\"err\": \"Failed to parse JSON: %d\"}")), num_tokens);
        return false;
    }

    int token = jsonfind(json, requestJsmnTokens, num_tokens, "method");

    if (token > 1) {
        {=# commands =}
        if (jsoneq(json, &requestJsmnTokens[token], FROM_ROM(TO_ROM("{= name =}")))) {
            if ({= fn =}({=# argv =}{= name =}{=^ last =}, {=/ last =}{=/ argv =})) {
                return true;
            } else {
                {=# error =}
                sprintf(retval, FROM_ROM(TO_ROM("{\"err\": \"{= error =}\"}")));
                {=/ error =}
                return false;
            }
        }
        {=/ commands =}
        {=# attrs =}
        {=# gen_set =}
        if (jsoneq(json, &requestJsmnTokens[token], FROM_ROM(TO_ROM("set_{= name =}")))) {
            return set_attr_{= name =}(json, requestJsmnTokens, num_tokens, retval);
        }
        {=/ gen_set =}
        if (jsoneq(json, &requestJsmnTokens[token], FROM_ROM(TO_ROM("get_{= name =}")))) {
            return get_attr_{= name =}(retval);
        }
        {=/ attrs =}
        {=# metrics =}
        {=# auto =}
        if (jsoneq(json, &requestJsmnTokens[token], FROM_ROM(TO_ROM("set_{= name =}_threshold")))) {
            return set_metric_{= name =}_threshold(json, requestJsmnTokens, num_tokens, retval);
        }
        if (jsoneq(json, &requestJsmnTokens[token], FROM_ROM(TO_ROM("get_{= name =}_threshold")))) {
            return get_metric_{= name =}_threshold(retval);
        }
        {=/ auto =}
        if (jsoneq(json, &requestJsmnTokens[token], FROM_ROM(TO_ROM("get_{= name =}")))) {
            return get_metric_{= name =}(retval);
        }
        {=/ metrics =}
        {=# has_timer =}
        if (jsoneq(json, &requestJsmnTokens[token], FROM_ROM(TO_ROM("set_timer")))) {
            return getset_timer(json, requestJsmnTokens, num_tokens, retval, true);
        }
        if (jsoneq(json, &requestJsmnTokens[token], FROM_ROM(TO_ROM("get_timer")))) {
            return getset_timer(json, requestJsmnTokens, num_tokens, retval, false);
        }
        {=/ has_timer =}
    }
    return false;
}

{=^ low_memory =}
func reportMetric(force bool) bool {
    bool wantSend = false;
    int total_length = 0;
    wantSendData[0] = '{';
    total_length += 1;

    {=# metrics =}
    {=# auto =}
    if ((is_valid_float(metric_{= name =}, {= min =}, {= max =}) && abs(last_metric_{= name =} - metric_{= name =}) > metric_{= name =}_threshold) || force) {
        tempSendData[0] = '\0';
        if (get_metric_{= name =}(tempSendData)) {
            merge_json(wantSendData, tempSendData, &total_length);
            wantSend = true;
            last_metric_{= name =} = metric_{= name =};
        }
    }

    {=/ auto =}
    {=/ metrics =}
    if (wantSend) {
        wantSendData[total_length-1] = '}';
        wantSendData[total_length] = '\0';

        send_packet_1(TELEMETRY, wantSendData, total_length);
        return true;
    }
    return false;
}

func reportAttribute(force bool) bool {
    int total_length = 0;
    bool wantSend = false;
    wantSendData[0] = '{';
    total_length += 1;

    {=# attrs =}
    if (last_attr_{= name =} != attr_{= name =} || force || attr_{= name =}_force) {
        tempSendData[0] = '\0';
        if (get_attr_{= name =}(tempSendData)) {
            merge_json(wantSendData, tempSendData, &total_length);
            wantSend = true;
            last_attr_{= name =} = attr_{= name =};
            attr_{= name =}_force = false;
        }
    }

    {=/ attrs =}
    {=# metrics =}
    {=# auto =}
    if (last_metric_{= name =}_threshold != metric_{= name =}_threshold || force || metric_{= name =}_threshold_force) {
        tempSendData[0] = '\0';
        if (get_metric_{= name =}_threshold(tempSendData)) {
            merge_json(wantSendData, tempSendData, &total_length);
            wantSend = true;
            last_metric_{= name =}_threshold = metric_{= name =}_threshold;
            metric_{= name =}_threshold_force = false;
        }
    }

    {=/ auto =}
    {=/ metrics =}
    if (wantSend) {
        wantSendData[total_length-1] = '}';
        wantSendData[total_length] = '\0';

        send_packet_1(ATTRIBUTE, wantSendData, total_length);
        return true;
    }
    return false;
}
{=/ low_memory =}
{=# low_memory =}
{=# has_metric =}
func is_valid_report_metric_index() bool {
    {=# metrics =}
    {=# auto =}
    if (report_metric_index == {= index =}) {
        return true;
    }

    {=/ auto =}
    {=/ metrics =}
    return false;
}

func report_metric_next_index() void {
    for (int i = 0; i < 20; i ++) {
        report_metric_index += 1;
        if (report_metric_index >= 20) {
            report_metric_index = 0;
        }
        if (is_valid_report_metric_index()) {
            break;
        }
    }
}

setup setup_report_metric_index {
    report_metric_next_index();
}

func reportMetric() bool {
    {=# metrics =}
    {=# auto =}
    if (metric_{= name =}_readed && ((is_valid_float(metric_{= name =}, {= min =}, {= max =}) && abs(last_metric_{= name =} - metric_{= name =}) > metric_{= name =}_threshold) || !metric_{= name =}_reported) && report_metric_index == {= index =}) {
        wantSendData[0] = '\0';
        if (get_metric_{= name =}(wantSendData)) {
            send_packet_1(TELEMETRY, wantSendData, get_json_length(wantSendData));
            cache_metric_{= name =} = metric_{= name =};
            return false;
        }
    }

    {=/ auto =}
    {=/ metrics =}
    report_metric_next_index();

    return true;
}

func doneReportMetric() void {
    {=# metrics =}
    {=# auto =}
    if (report_metric_index == {= index =}) {
        last_metric_{= name =} = cache_metric_{= name =};
        metric_{= name =}_reported = true;
        metric_{= name =}_readed = false;
    }

    {=/ auto =}
    {=/ metrics =}
    report_metric_next_index();
}

func setReportMetricAll() void {
    {=# metrics =}
    {=# auto =}
    metric_{= name =}_reported = false;
    {=/ auto =}
    {=/ metrics =}
}

{=/ has_metric =}
func is_valid_report_attr_index() bool {
    {=# attrs =}
    if (report_attr_index == {= index =}) {
        return true;
    }

    {=/ attrs =}
    {=# metrics =}
    {=# auto =}
    if (report_attr_index == {= index =}) {
        return true;
    }

    {=/ auto =}
    {=/ metrics =}
    return false;
}

func report_attr_next_index() void {
    for (int i = 0; i < 20; i ++) {
        report_attr_index += 1;
        if (report_attr_index >= 20) {
            report_attr_index = 0;
        }
        if (is_valid_report_attr_index()) {
            break;
        }
    }
}

{=# has_app =}
setup setup_report_attr_index {
    report_attr_next_index();
}
{=/ has_app =}

func reportAttribute() bool {
    {=# attrs =}
    if ((last_attr_{= name =} != attr_{= name =} || !attr_{= name =}_reported) && report_attr_index == {= index =}) {
        wantSendData[0] = '\0';
        if (get_attr_{= name =}(wantSendData)) {
            send_packet_1(ATTRIBUTE, wantSendData, get_json_length(wantSendData));
            cache_attr_{= name =} = attr_{= name =};
            return false;
        }
    }

    {=/ attrs =}
    {=# metrics =}
    {=# auto =}
    if ((last_metric_{= name =}_threshold != metric_{= name =}_threshold || !metric_{= name =}_threshold_reported) && report_attr_index == {= index =}) {
        wantSendData[0] = '\0';
        if (get_metric_{= name =}_threshold(wantSendData)) {
            send_packet_1(ATTRIBUTE, wantSendData, get_json_length(wantSendData));
            cache_metric_{= name =}_threshold = metric_{= name =}_threshold;
            return false;
        }
    }

    {=/ auto =}
    {=/ metrics =}

    report_attr_next_index();
    return true;
}

func doneReportAttribute() void {
    {=# attrs =}
    if (report_attr_index == {= index =}) {
        last_attr_{= name =} = cache_attr_{= name =};
        attr_{= name =}_reported = true;
    }

    {=/ attrs =}
    {=# metrics =}
    {=# auto =}
    if (report_attr_index == {= index =}) {
        last_metric_{= name =}_threshold = cache_metric_{= name =}_threshold;
        metric_{= name =}_threshold_reported = true;
    }

    {=/ auto =}
    {=/ metrics =}

    report_attr_next_index();
}
{=/ low_memory =}

sys_timer_s         uint32_t = 0
sys_timer_synced_ms uint32_t = 0
next_timer_event_ms uint32_t = 0
timer_delta0_ms     uint32_t = 0
timer_delta1_ms     uint32_t = 0
timer_schedat_s     uint32_t = 0
timer_period_s      uint32_t = 0
timer_duration_s    uint32_t = 0
timer_action uint8_t = 0
SYNCTIME_DELAY_MS = 3600000

{=# timers =}
timer_{= name =}_sched bool = false
{=/ timers =}

{=# has_timer =}
timer_buf[11] uint8_t

// one week 7 * 24 * 60 * 60
MAX_TIMER_DURATION = 604800

// two month 60 * 24 * 60 * 60
MAX_TIMER_PERIOD = 5184000

loop timer_loop {
    if (sys_timer_s > 0 && next_timer_event_ms <= get_cache_time_ms()) {
        {=# timers =}
        processTimer({= addr0 =}, {= addr1 =}, {= addr2 =}, &timer_{= name =}_sched);
        if (timer_action == 1) {
            {= fn0 =}();
        } else if (timer_action == 2) {
            {= fn1 =}();
        }

        {=/ timers =}
        if (next_timer_event_ms < get_cache_time_ms()) {
            next_timer_event_ms += 60000;
        }
    }
}
{=/ has_timer =}

func swap_timer_event(delta_ms uint32_t) void {
    if (delta_ms <= get_cache_time_ms()) {
        return;
    }
    if (next_timer_event_ms > get_cache_time_ms()) {
        if (next_timer_event_ms > delta_ms) {
            next_timer_event_ms = delta_ms;
        }
    } else {
        next_timer_event_ms = delta_ms;
    }
}

func get_value(buf const char *, start_ptr int *) uint32_t {
    int length = strlen(buf);
    int start = *start_ptr;

    int n = 0;
    while (start < length) {
        if (buf[start] == ',') {
            start += 1;
            break;
        }
        if (isdigit(buf[start])) {
            timer_buf[n] = buf[start];
            n += 1;
        }
        start += 1;
    }

    *start_ptr = start;
    timer_buf[n] = '\0';

    if (n > 0) {
        return (uint32_t)atol(timer_buf);
    } else {
        return 0;
    }
}

func set_timer_raw(json const char *, tokens jsmntok_t *, num_tokens int, addr0 int, addr1 int, addr2 int) void {
    if (jsonlookup(json, tokens, num_tokens, FROM_ROM(TO_ROM("data")), requestValue)) {
        int pos = 0;
        timer_schedat_s  = get_value(requestValue, &pos);
        timer_period_s   = get_value(requestValue, &pos);
        timer_duration_s = get_value(requestValue, &pos);

        if (timer_duration_s > MAX_TIMER_DURATION) {
            timer_duration_s = MAX_TIMER_DURATION - 100;
        }

        if (timer_period_s > MAX_TIMER_PERIOD) {
            timer_period_s = MAX_TIMER_PERIOD - 100;
        }

        STROAGE_PUT(addr0, timer_schedat_s);
        STROAGE_PUT(addr1, timer_period_s);
        STROAGE_PUT(addr2, timer_duration_s);
        STROAGE_COMMIT();
        swap_timer_event(get_cache_time_ms() + 5);
    }
}

func get_timer_raw(addr0 int, addr1 int, addr2 int, retval char *) bool {
    STROAGE_GET(addr0, timer_schedat_s);
    STROAGE_GET(addr1, timer_period_s);
    STROAGE_GET(addr2, timer_duration_s);
    sprintf(retval, FROM_ROM(TO_ROM("{\"sched_at\": %ld, \"period\": %ld, \"duration\": %ld}")), timer_schedat_s, timer_period_s, timer_duration_s);
    return true;
}

func getset_timer(json const char *, tokens jsmntok_t *, num_tokens int, retval char *, set bool) bool {
    int token = jsonfind(json, tokens, num_tokens, "name");
    if (token > 1) {
        {=# timers =}
        if (jsoneq(json, &tokens[token], FROM_ROM(TO_ROM("{= name =}")))) {
            if (set) {
                set_timer_raw(json, tokens, num_tokens, {= addr0 =}, {= addr1 =}, {= addr2 =});
            }
            return get_timer_raw({= addr0 =}, {= addr1 =}, {= addr2 =}, retval);
        }
        {=/ timers =}
    }
    return false;
}

func finishTimer(addr0 int, addr2 int, sched bool *) void {
    timer_delta1_ms = (timer_schedat_s - sys_timer_s + timer_duration_s) * 1000 + sys_timer_synced_ms;
    if (timer_delta1_ms <= get_cache_time_ms()) {
        if (*sched) {
            *sched = false;
            timer_action = 2;
        }
        if (timer_period_s > timer_duration_s && timer_period_s < MAX_TIMER_PERIOD) {
            timer_schedat_s += timer_period_s;
            STROAGE_PUT(addr0, timer_schedat_s);
            STROAGE_COMMIT();
            timer_delta0_ms = (timer_schedat_s - sys_timer_s) * 1000 + sys_timer_synced_ms;
        } else {
            stopTimer(addr2);
        }
    }
}

func startTimer(addr0 int, addr2 int, sched bool *) void {
    timer_delta1_ms = (timer_schedat_s + timer_duration_s - sys_timer_s) * 1000 + sys_timer_synced_ms;
    if (timer_delta1_ms > get_cache_time_ms()) {
        *sched = true;
        timer_action = 1;
    } else {
        finishTimer(addr0, addr2, sched);
    }
    return;
}

func stopTimer(addr2 int) void {
    STROAGE_PUT(addr2, 0);
    STROAGE_COMMIT();
}

func processTimer(addr0 int, addr1 int, addr2 int, sched bool *) void {
    processTimer0(addr0, addr1, addr2, sched);
    swap_timer_event(timer_delta0_ms);
    swap_timer_event(timer_delta1_ms);
}

func processTimer0(addr0 int, addr1 int, addr2 int, sched bool *) void {
    timer_action = 0;
    STROAGE_GET(addr0, timer_schedat_s);
    STROAGE_GET(addr1, timer_period_s);
    STROAGE_GET(addr2, timer_duration_s);

    if (*sched) {
        finishTimer(addr0, addr2, sched);
        return;
    }


    if (timer_duration_s == 0 || timer_duration_s > MAX_TIMER_DURATION) {
        return;
    }

    if (timer_schedat_s < sys_timer_s) {
        if (timer_schedat_s + timer_duration_s < sys_timer_s) {
            if (timer_period_s == 0 || timer_period_s > MAX_TIMER_PERIOD) {
                stopTimer(addr2);
                return;
            }
            for (int i = 0; i < 100000; i ++) {
                timer_schedat_s += timer_period_s;
                if (timer_schedat_s > sys_timer_s) {
                    break;
                }
            }
            if (timer_schedat_s < sys_timer_s) {
                stopTimer(addr2);
                return;
            } else {
                STROAGE_PUT(addr0, timer_schedat_s);
                STROAGE_COMMIT();
            }
        } else {
            startTimer(addr0, addr2, sched);
            return;
        }
    }

    timer_delta0_ms = (timer_schedat_s - sys_timer_s) * 1000 + sys_timer_synced_ms;

    if (timer_delta0_ms <= get_cache_time_ms()) {
        startTimer(addr0, addr2, sched);
    }
}

func get_cache_time_ms() unsigned long {
    return current_time_ms;
}

{=# actions =}
// start actions
every_{= id =}_timer_ms unsigned long = 0
loop every_{= id =}_loop {
    {=# has_on =}
    if ({=& on =} && every_{= id =}_timer_ms + {= delay_ms =} < get_cache_time_ms()) {
    {=/ has_on =}
    {=^ has_on =}
    if (every_{= id =}_timer_ms + {= delay_ms =} < get_cache_time_ms()) {
    {=/ has_on =}
        {= fn =}();
        every_{= id =}_timer_ms = get_cache_time_ms();
    }
}
// end actions
{=/ actions =}

// start rules
rule_depends_checked bool = false
{=# rules =}
{=# has_later =}
rule_{= id =}_do_yes_timer_ms unsigned long = 0
{=/ has_later =}
{=# has_else_later =}
rule_{= id =}_do_else_timer_ms unsigned long = 0
{=/ has_else_later =}
rule_{= id =}_do_yes bool = true
{=# has_else =}
rule_{= id =}_do_else bool = true
{=/ has_else =}
func rule_{= id =}_poll() void {
    {=# has_later =}
    if ({=& condition =}) {
        if (rule_{= id =}_do_yes && rule_{= id =}_do_yes_timer_ms + {= later =} < get_cache_time_ms()) {
            rule_{= id =}_do_yes = false;
            {= action =}();
        }
        {=# has_else =}
        rule_{= id =}_do_else = true;
        {=# has_else_later =}
        rule_{= id =}_do_else_timer_ms = get_cache_time_ms();
        {=/ has_else_later =}
        {=/ has_else =}
    } else {
        rule_{= id =}_do_yes = true;
        rule_{= id =}_do_yes_timer_ms = get_cache_time_ms();
        {=# has_else =}
        if (rule_{= id =}_do_else) {
            rule_{= id =}_do_else = false;
            {=# has_else_later =}
            if (rule_{= id =}_do_else && rule_{= id =}_do_else_timer_ms + {= else_later =} < get_cache_time_ms()) {
                {= else_action =}();
            }
            {=/ has_else_later =}
            {=^ has_else_later =}
            {= else_action =}();
            {=/ has_else_later =}
        }
        {=/ has_else =}
    }
    {=/ has_later =}
    {=^ has_later =}
    if ({=& condition =}) {
        if (rule_{= id =}_do_yes) {
            rule_{= id =}_do_yes = false;
            {= action =}();
        }
        {=# has_else =}
        rule_{= id =}_do_else = true;
        {=# has_else_later =}
        rule_{= id =}_do_else_timer_ms = get_cache_time_ms();
        {=/ has_else_later =}
        {=/ has_else =}
    } else {
        rule_{= id =}_do_yes = true;
        {=# has_else =}
        if (rule_{= id =}_do_else) {
            rule_{= id =}_do_else = false;
            {=# has_else_later =}
            if (rule_{= id =}_do_else_timer_ms + {= else_later =} < get_cache_time_ms()) {
                {= else_action =}();
            }
            {=/ has_else_later =}
            {=^ has_else_later =}
            {= else_action =}();
            {=/ has_else_later =}
        }
        {=/ has_else =}
    }
    {=/ has_later =}
}

loop rule_{= id =}_loop {
    {=# has_dep =}
    rule_depends_checked = true;
    {=# depends =}
    if (!check_metric_{= . =}()) {
        rule_depends_checked = false;
    }
    {=/ depends =}
    {=# has_on =}
    if (rule_depends_checked && ({=& on_condition =})) {
    {=/ has_on =}
    {=^ has_on =}
    if (rule_depends_checked) {
    {=/ has_on =}
        rule_{= id =}_poll();
    }
    {=/ has_dep =}
    {=^ has_dep =}
    {=# has_on =}
    if ({=& on_condition =}) {
        rule_{= id =}_poll();
    }
    {=/ has_on =}
    {=^ has_on =}
    rule_{= id =}_poll();
    {=/ has_on =}
    {=/ has_dep =}
}
{=/ rules =}
// end rules

DEBOUNCE_DELAY_MS = 50
gpio_reading uint8_t = 0

{=# gpios =}
{=# bind =}
gpio_{= name =}_state uint8_t = {= state =}
{=# is_fn =}
last_gpio_{= name =}_debounce_time_ms unsigned long = 0
last_gpio_{= name =}_state uint8_t = {= state =}
{=/ is_fn =}
{=/ bind =}
setup setup_gpio_{= name =} {
    {=# bind =}
    {=# is_link =}
    pinMode({= pin =}, OUTPUT);
    digitalWrite({= pin =}, gpio_{= name =}_state);
    {=/ is_link =}
    {=# is_fn =}
    pinMode({= pin =}, INPUT);
    {=/ is_fn =}
    {=# is_pwm =}
    analogWrite({= pin =}, gpio_{= name =}_state);
    {=/ is_pwm =}
    {=# is_no_bind =}
    pinMode({= pin =}, OUTPUT);
    digitalWrite({= pin =}, gpio_{= name =}_state);
    {=/ is_no_bind =}
    {=/ bind =}
}
loop gpio_{= name =}_loop {
    {=# bind =}
    {=# is_fn =}
    gpio_reading = digitalRead({= pin =});
    if (gpio_reading != last_gpio_{= name =}_state) {
        last_gpio_{= name =}_debounce_time_ms = get_cache_time_ms();
    }
    if ((get_cache_time_ms() - last_gpio_{= name =}_debounce_time_ms) > DEBOUNCE_DELAY_MS) {
        if (gpio_reading != gpio_{= name =}_state) {
          gpio_{= name =}_state = gpio_reading;
          if (gpio_{= name =}_state == {= emit =}) {
            {= fn =}();
          }
        }
    }
    last_gpio_{= name =}_state = gpio_reading;

    {=/ is_fn =}
    {=# is_link =}
    {=# reverse =}
    if (attr_{= link =} == gpio_{= name =}_state) {
        if (attr_{= link =} == {= open =}) {
            close_gpio_{= name =}_raw();
        } else {
            open_gpio_{= name =}_raw();
        }
    }
    {=/ reverse =}
    {=^ reverse =}
    if (attr_{= link =} != gpio_{= name =}_state) {
        if (attr_{= link =} == {= open =}) {
            open_gpio_{= name =}_raw();
        } else {
            close_gpio_{= name =}_raw();
        }
    }
    {=/ reverse =}

    {=/ is_link =}
    {=# is_pwm =}
    if (attr_{= link =} != gpio_{= name =}_state) {
      gpio_{= name =}_state = attr_{= link =};
      analogWrite({= pin =}, gpio_{= name =}_state);
    }
    {=/ is_pwm =}
    {=/ bind =}
}
{=# bind =}
{=# is_link =}
func open_gpio_{= name =}_raw() void {
    gpio_{= name =}_state = {= open =};
    digitalWrite({= pin =}, gpio_{= name =}_state);
}

func close_gpio_{= name =}_raw() void {
    gpio_{= name =}_state = {= close =};
    digitalWrite({= pin =}, gpio_{= name =}_state);
}

func open_gpio_{= name =}() void {
    {=# reverse =}
    set_attr_{= link =}_raw({= close =});
    {=/ reverse =}
    {=^ reverse =}
    set_attr_{= link =}_raw({= open =});
    {=/ reverse =}
}

func close_gpio_{= name =}() void {
    {=# reverse =}
    set_attr_{= link =}_raw({= open =});
    {=/ reverse =}
    {=^ reverse =}
    set_attr_{= link =}_raw({= close =});
    {=/ reverse =}
}

func toggle_gpio_{= name =}() void {
    if (attr_{= link =} == {= open =}) {
        set_attr_{= link =}_raw({= close =});
    } else {
        set_attr_{= link =}_raw({= open =});
    }
}

{=/ is_link =}
{=# is_no_bind =}
func open_gpio_{= name =}() void {
    gpio_{= name =}_state = {= open =};
    digitalWrite({= pin =}, gpio_{= name =}_state);
}

func close_gpio_{= name =}() void {
    gpio_{= name =}_state = {= close =};
    digitalWrite({= pin =}, gpio_{= name =}_state);
}

func toggle_gpio_{= name =}() void {
    if (gpio_{= name =}_state == {= open =}) {
        close_gpio_{= name =}();
    } else {
        open_gpio_{= name =}();
    }
}

{=/ is_no_bind =}
{=/ bind =}
{=/ gpios =}

{=# agpios =}
{=# bind =}
{=# is_no_bind =}
agpio_{= name =}_value uint16_t = 0
{=/ is_no_bind =}
{=/ bind =}
loop agpio_{= name =}_loop {
    {=# bind =}
    {=# is_link =}
    metric_{= link =} = analogRead({= pin =});
    {=/ is_link =}
    {=# is_no_bind =}
    agpio_{= name =}_value = analogRead({= pin =});
    {=/ is_no_bind =}
    {=/ bind =}
}
{=/ agpios =}


import <givelink_common.h> https://github.com/Lupino/givelink.git
{=# uarts =}
{= name =}_availabled_timer_ms unsigned long
{= name =}_writer_timer_ms unsigned long
{=# readers =}
{= name =}_read_{= index =}_buffer[{= buf_len =} + 1] uint8_t
{= name =}_read_{= index =}_buffer_len int = 0
is_{= name =}_{= index =}_readed bool = false
is_{= name =}_{= index =}_readed_flag bool = false
{=/ readers =}
{=# writers =}
is_{= name =}_write_{= wname =} bool = false
{=# action =}
{=# is_gen =}
{= name =}_write_{= wname =}_buffer[{= buf_len =} + 1] uint8_t
{= name =}_write_{= wname =}_buffer_len int = 0
{=/ is_gen =}
{=/ action =}
{=/ writers =}
{= name =}_write_index uint8_t = 0
loop {= name =}_poll_loop {
    {= name =}_poll();
}
func {= name =}_poll() void {
    if ({= name =}.available() > 0) {
        {= name =}_availabled_timer_ms = get_current_time_ms();
        {=# readers =}
        is_{= name =}_{= index =}_readed = false;
        {=/ readers =}
        while ({= name =}.available() > 0) {
            uint8_t outByte = {= name =}.read();
            {=# readers =}
            if (!is_{= name =}_{= index =}_readed_flag{=# has_on =} && ({=& on =}){=/ has_on =}) {
                if ({= reader =}(outByte, {= name =}_read_{= index =}_buffer, &{= name =}_read_{= index =}_buffer_len)) {
                    is_{= name =}_{= index =}_readed_flag = true;
                }
                if ({= name =}_read_{= index =}_buffer_len > {= buf_len =}) {
                    givelink_shift_data_raw({= name =}_read_{= index =}_buffer, {= name =}_read_{= index =}_buffer_len);
                    {= name =}_read_{= index =}_buffer_len -= 1;
                }
            }
            {=/ readers =}
        }
        {=# readers =}
        if (is_{= name =}_{= index =}_readed_flag) {
            is_{= name =}_{= index =}_readed_flag = false;
            is_{= name =}_{= index =}_readed = true;
        }
        {=/ readers =}
        {=# readers =}
        if (is_{= name =}_{= index =}_readed) {
            {= parser =}({= name =}_read_{= index =}_buffer, {= name =}_read_{= index =}_buffer_len);
            {= name =}_read_{= index =}_buffer_len = 0;
        }
        {=/ readers =}
    }
}

{=# writers =}
func {= name =}_write_{= wname =}() void {
    prepare_{= name =}_write();
    is_{= name =}_write_{= wname =} = true;
    {=# readers =}
    is_{= name =}_{= index =}_readed = false;
    {=/ readers =}
    {=# action =}
    {=# is_cmd =}
    {=# bytes =}
    {= name =}.write((uint8_t)0x{= . =});
    {=/ bytes =}
    {=/ is_cmd =}
    {=# is_gen =}
    {= gen =}({= name =}_write_{= wname =}_buffer, &{= name =}_write_{= wname =}_buffer_len);
    for (int i = 0; i < {= name =}_write_{= wname =}_buffer_len; i ++) {
      {= name =}.write({= name =}_write_{= wname =}_buffer[i]);
    }
    {=/ is_gen =}
    {=/ action =}
}

{=/ writers =}
func {= name =}_is_valid_index() bool {
    {=# writers =}
    {=# auto =}
    {=# has_on =}
    if ({=& on =}) {
        if ({= name =}_write_index == {= index =}) {
            return true;
        }
    }
    {=/ has_on =}
    {=^ has_on =}
    if ({= name =}_write_index == {= index =}) {
        return true;
    }
    {=/ has_on =}
    {=/ auto =}
    {=/ writers =}
    return false;
}

func {= name =}_write_next_index() void {
    for (int i = 0; i < {= wcount =}; i ++) {
        {= name =}_write_index += 1;
        if ({= name =}_write_index >= {= wcount =}) {
            {= name =}_write_index = 0;
        }
        if ({= name =}_is_valid_index()) {
            break;
        }
    }
}

func prepare_{= name =}_write() void {
    if ({= name =}_writer_timer_ms + 200 > get_current_time_ms()) {
        while ({= name =}_writer_timer_ms + 200 > get_current_time_ms()) {
            {= name =}_poll();
        }
    }
    {=# writers =}
    is_{= name =}_write_{= wname =} = false;
    {=/ writers =}
    {= name =}_writer_timer_ms = get_current_time_ms();
}

func {= name =}_write() void {
    {=# writers =}
    {=# auto =}
    {=# has_on =}
    if ({=& on =}) {
        if ({= name =}_write_index == {= index =}) {
            {= name =}_write_{= wname =}();
        }
    }
    {=/ has_on =}
    {=^ has_on =}
    if ({= name =}_write_index == {= index =}) {
        {= name =}_write_{= wname =}();
    }
    {=/ has_on =}
    {=/ auto =}
    {=/ writers =}
    {= name =}_write_next_index();
}

{=/ uarts =}

require ./utils
require ./stroage
